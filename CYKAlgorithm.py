import sys
import numpy as np

CHOICE = 0

#Some grammars, and two test examples for each grammar
GRAMMARS = ['Grammar1.txt', 'Grammar2.txt', 'Grammar3.txt']
TESTSTRINGS = [('baaba','babba'),('aaabbb','aaabb'),('she eats a fish with a fork','she eats with a fork a fish')]

GRAMMARPATH = GRAMMARS[CHOICE]
CORRECTTESTSTRING = TESTSTRINGS[CHOICE][0]
INCORRECTTESTSTRING = TESTSTRINGS[CHOICE][1]

def getProduction(grammarPath):
	""" Method to save productions in more manageable data """
	productions = []
	grammar = open(grammarPath).read()
	p = (grammar.split("PRODUCTIONS:\n")[1].replace("\n", ",").split(','))

	for rule in p:
		left = rule.split(' -> ')[0]
		right = rule.split(' -> ')[1].split(' | ')
		for element in right:
			productions.append((left, element))

	return productions

def getVariables(grammarPath):
	""" Method to save variables in more manageable data """
	grammar = open(grammarPath).read()
	variables = (grammar.split("VARIABLES:\n")[1].split("PRODUCTIONS:\n")[0].replace("VARIABLES\n","").replace("\n", "").split(' '))

	return variables

def getTerminals(grammarPath):
	""" Method to save variables in more manageable data """
	grammar = open(grammarPath).read()
	terminals = (grammar.split("VARIABLES:\n")[0].replace("TERMINALS:\n","").replace("\n","").split(' '))
	
	return terminals

def wordsIn(s, terms):
	""" Method to count how many terminals are used in the tested string """
	if ' ' in s:
		splits = s.split(' ')
		return len(splits)
	else:
		return len(s)

def unitProductionUpdate(symbol, symbolPos, rules, variables, table):
	""" Method that implements the first pass of the algorithm: this pass wants to resolve productions like Variables -> terminalSymbol """
	for rule in rules:
		if symbol == rule[1]: 
			varPos = variables.index(rule[0])
			table[0,symbolPos,varPos] = 1

def productionUpdate(rules, variables, terminals, table, l, s, p):
	""" Method that implements the other passes of the algorithm: this passes wants to resolve productions like Variables -> Var1 Var2 """
	for rule in rules:

		left = rule[0] #it should works, assuming CNF grammars.
		leftPos = variables.index(left)

		right = rule[1]

		if right not in terminals:
			right1 = right.split(' ')[0]
			right2 = right.split(' ')[1]
			right1Pos = variables.index(right1)
			right2Pos = variables.index(right2)

			if table[p, s, right1Pos] == 1 and table[l-p-1, s+p+1, right2Pos] == 1:
				table[l,s,leftPos] = 1
		
def CYKAlgorithm(string, pRules, var, terms):
	""" Method to run the CYK Parsing Algorithm """
	N = wordsIn(string, terms)

	P = len(var)
	result = False

	#Table initialization
	table = np.zeros((N,N,P)) # zeros corresponds to False

	#Analyzing substrings with length 1
	if ' ' in string:
		splits = string.split(' ')
		for s in range(1, N+1):
			unitProductionUpdate(splits[s-1], s-1, pRules, var, table)
	else:
		for s in range(1, N+1):
			unitProductionUpdate(string[s-1], s-1, pRules, var, table)

	#Analyzing substrings with length greater than 1, until N
	for l in range(2,N+1): #l = length of the substring
		for s in range(1,N-l+2): #s = how many substrings of length l are in the tested string. In particular it is used to define the start position of the substrings with length l
			for p in range(1,l): #p let us to consider different combination of sub-spans and it tells us how we split the span generated by l
				productionUpdate(pRules, var, terms, table, l-1, s-1, p-1)

	if table[N-1,0,0] == 1:
		result = True
		print('String \'' + string + '\' belongs to the selected grammar.' )
	else:
		print('String \'' + string + '\' does not belong to the selected grammar.' )

	return result

if __name__ == '__main__':

	terminals = getTerminals(GRAMMARPATH) 
	variables = getVariables(GRAMMARPATH)
	productions = getProduction(GRAMMARPATH)
	
	goodResult = CYKAlgorithm(CORRECTTESTSTRING, productions, variables, terminals)
	badResult = CYKAlgorithm(INCORRECTTESTSTRING, productions, variables, terminals)
